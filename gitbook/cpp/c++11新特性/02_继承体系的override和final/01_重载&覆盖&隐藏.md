# 重载&覆盖&隐藏

## 重载(overload)函数

在**同一个作用域**中，具有**相同函数名**，**相同返回值**，而参数列表(**参数类型或参数个数**)不同的函数，都称为重载函数。

**1.函数名相同，参数列表相同，返回值不同**

```c++
#include <iostream>
using namespace std;

void Show(int a)
{
    cout << "void Show int a = " << a << endl;
}

int Show(int a)
{
    cout << "int Show int a = " << a << endl;
}

int main()
{
    return 0;
}
```

编译输出：**编译错误**，重定义导致的歧义

```c++

xxxxx\test.cpp: In function 'int Show(int)':
xxxxx\test.cpp:9:15: error: ambiguating new declaration of 'int Show(int)'
 int Show(int a)
               ^
xxxxx\test.cpp:4:6: note: old declaration 'void Show(int)'
 void Show(int a)
      ^
The terminal process terminated with exit code: 1
```

**2.函数名相同，返回值相同，参数类型不同**

```c++
#include <iostream>
using namespace std;

void Show(int a, int b)
{
    cout << "int a = " << a << " int b = " << b << endl;
}

void Show(int a, float b)
{
    cout << "int a = " << a << " float b = " << b << endl;
}

int main()
{
    Show(1, 2);
    Show(1, 2.0f);

    return 0;
}
```

代码输出：

```c++
int a = 1 int b = 2
int a = 1 float b = 2
```

**思考：**

如果改成如下的方式，会出现什么情况？

```c++
#include <iostream>
using namespace std;

void Show(int a, int b)
{
    cout << "int a = " << a << " int b = " << b << endl;
}

void Show(int b, int a)
{
    cout << "int b = " << b << " int a = " << a << endl;
}

int main()
{
    return 0;
}
```

我们先对第二个例子生成的`test.exe`进行处理：
* 环境：`g++.exe (i686-posix-dwarf-rev1, Built by MinGW-W64 project) 4.9.2`
* 命令：`nm test.exe | grep Show`

查看的符号表如下：
```c++
0040174f t __GLOBAL__sub_I__Z4Showii
00401671 T __Z4Showif
00401610 T __Z4Showii
```

说明:
* _Z4是编译器添加的前缀
* Show即为我们的函数名
* if：表示第一个参数为int，第二个参数为float
* ii：表示两个参数都为int

**思考答案：**
编译失败！！！
因为编译器是以**函数名+参数类型+参数个数**来区分重载函数的，与变量名字无关。

