# 装饰器

顾明思义，就是对原对象进行装饰，在不改变原对象的情况下，增加更多的功能。比如，手机(原对象)上贴膜(保护屏幕功能)和加装手机壳(保护手机，防止摔坏)等新功能，未改变原有对象。

装饰器一般形式：

```python
def decorator(func):
    @wraps(func)
    def inner(*args, **kwargs):
        # ...
        return func(*args, **kwargs)
    
    return inner

@decorator
def func():
    pass
```

等价于：

```python
func = decorator(func)
```

模块被**导入**的时候，将被调用装饰动作。

* classmethod装饰器
* staticmethod装饰器
* 一般装饰器
* 带参装饰器
* 多层装饰器
* 装饰器注册

## classmethod装饰

使用`classmethod`修饰后，被装饰的函数foo将成为类的函数方法，可使用cls.foo直接调用，也可以访问类属性。

```python
class Demo(object):
    _a = 10
    def __init__(self):
        pass

    @classmethod
    def foo(cls, num):
        print(f"a = {cls._a}, num = {num}")

if __name__ == "__main__":
    Demo.foo(3)
```

代码输出：

```python
a = 10, num = 3
```

*** 

## staticmethod装饰器

使用`staticmethod`修饰后，被装饰的函数foo将成为类的函数方法，可使用cls.foo直接调用，但不能访问类属性。

```python
class Demo(object):
    _a = 10
    def __init__(self):
        pass

    @staticmethod
    def foo(num):
        print(f"num = {num}")

if __name__ == "__main__":
    Demo.foo(3)
```

代码输出：

```python
num = 3
```

*** 

## 一般装饰器

```python
def decorator(func):
    print(f"{decorator.__name__} {func.__name__} in")
    def inner(*args, **kwargs):
        print(f"{inner.__name__} in")
        result = func(*args, **kwargs)
        print(f"{inner.__name__} out")

        return result

    print(f"{decorator.__name__} {func.__name__} out")

    return inner

@decorator
def foo1():
    print(f"{foo1.__name__}")

@decorator
def foo2(a):
    print(f"{foo1.__name__} a = {a}")

@decorator
def foo3(a, b):
    print(f"{foo1.__name__} a = {a}, b = {b}")

if __name__ == "__main__":
    print("main")
    foo1()
    foo2(10)
    foo3(10, 20
```

代码输出：

```python
decorator foo1 in    
decorator foo1 out   
decorator foo2 in    
decorator foo2 out   
decorator foo3 in    
decorator foo3 out   
main                 
inner in             
inner                
inner out            
inner in             
inner a = 10         
inner out            
inner in             
inner a = 10, b = 20 
inner out            
```

FAQ: 被装饰对象的函数名已经被inner覆盖，有和解决之法？

只要在inner上方添加：

```python
@wraps(inner)
```

修改后如下：

```python
from functools import wraps

def decorator(func):
    print(f"{decorator.__name__} {func.__name__} in")

    @wraps(func)
    def inner(*args, **kwargs):
        print(f"{inner.__name__} in")
        result = func(*args, **kwargs)
        print(f"{inner.__name__} out")

        return result

    print(f"{decorator.__name__} {func.__name__} out")

    return inner

@decorator
def foo1():
    print(f"{foo1.__name__}")

@decorator
def foo2(a):
    print(f"{foo1.__name__} a = {a}")

@decorator
def foo3(a, b):
    print(f"{foo1.__name__} a = {a}, b = {b}")

if __name__ == "__main__":
    print("main")
    foo1()
    foo2(10)
    foo3(10, 20)
```

代码输出：

```python
decorator foo1 in   
decorator foo1 out  
decorator foo2 in   
decorator foo2 out  
decorator foo3 in   
decorator foo3 out  
main                
foo1 in             
foo1                
foo1 out            
foo2 in             
foo1 a = 10         
foo2 out            
foo3 in             
foo1 a = 10, b = 20 
foo3 out            
```

*** 


## 带参装饰器

*** 


## 多层装饰器

*** 


## 装饰器注册

